"""

    This file is a part of the Scratch to C
    project and distributed under the MIT license.

    Copyright Â© Kadir Aksoy
    https://github.com/kadir014/scratch2c

"""

from datetime import datetime

from .common import Project, Target
from .syntaxtree import *
from .terminal import info
#from .visualize import plot_ast


FILE_DOC = \
f"""
/*

  This file was generated by the Scratch2C transpiler.

  +----------------------------------------+
  | Please do not manually edit this file  |
  | as it was generated automatically!     |
  +----------------------------------------+

  Scratch2C Project
  Github: https://github.com/kadir014/scratch2c

  Generated on: {datetime.now().strftime("%d/%m/%Y at %H:%M:%S")}

  For support or issues, please use the issue tracker:
    https://github.com/kadir014/scratch2c/issues
  
*/
""".strip()


OP_MAP = {
    BinOpType.ADD: "+",
    BinOpType.SUB: "-",
    BinOpType.MUL: "*",
    BinOpType.DIV: "/",
    BinOpType.MOD: "%",
    BinOpType.EQ: "==",
    BinOpType.LT: "<",
    BinOpType.GT: ">",
    BinOpType.AND: "&&",
    BinOpType.OR: "||",
}
        

def generate_from_node(node: Node, target: Target) -> str:
    if isinstance(node, Literal):
        if node.type == LiteralType.NUMBER:
            return f"{node.value}"
        
        else:
            return node.value
        
    elif isinstance(node, Variable):
        return f"g_{node.name}.value_real"

    elif isinstance(node, Assignment):
        # get if variable is global from variable table
        return f"g_{node.variable.name}.value_real = ({generate_from_node(node.expression, target)});\n"
    
    elif isinstance(node, MotionTurn):
        return f"sprite->angle {('-', '+')[node.cw]}= {generate_from_node(node.angle, target)};\n"
    
    elif isinstance(node, Repeat):
        inner_code = []
        for inner_node in node.body:
            inner_code.append(generate_from_node(inner_node, target))

        code = f"SC_REPEAT((sc_uint64)({generate_from_node(node.times, target)})) {{\n"
        for stmt in inner_code:
            code += f"    {stmt}"
        code += "\n}"
        return code
    
    elif isinstance(node, If):
        inner_code = []
        for inner_node in node.body:
            inner_code.append(generate_from_node(inner_node, target))

        code = f"if ({generate_from_node(node.condition, target)}) {{\n"
        for stmt in inner_code:
            code += f"    {stmt}"
        code += "\n}"
        return code

    elif isinstance(node, BinOp):
        return f"{generate_from_node(node.left, target)} {OP_MAP[node.type]} {generate_from_node(node.right, target)}"
    
    elif isinstance(node, FunctionCall):
        args = []
        for arg in node.arguments:
            args.append(f"SC_VARIABLE_REAL({generate_from_node(arg, target)})")

        func = f"proc{id(target)}_{node.function}"

        return f"{func}(sprite, {', '.join(args)});\n"
    
    elif isinstance(node, FunctionArgument):
        return f"{node.name}.value_real"

def generate_code(project: Project) -> str:
    targets = project.targets

    code = ""

    code += FILE_DOC
    
    code += """
    
#include "scratch/scratch.h"


/* Global project configuration */

scProject project;
scEngine *engine;


/* Global (stage) variables */

"""

    stage = [t for t in targets if t.is_stage][0]

    stage_vars_code = ""
    for var in stage.variables:
        code += f"scVariable g_{var.name};\n"
        stage_vars_code += f"g_{var.name}.value_real = {var.value};\n"

    code += "\n\n"

    info(f"Parsing procedure definitions")
    for i, target in enumerate(targets):
        for script in target.procedures:
            if script.opcode == "procedures_definition":
                funcdef = generate_ast_procdef(script)
                #plot_ast(funcdef.body)

                inner_code = []
                for node in funcdef.body:
                    inner_code.append(generate_from_node(node, target))

                funcname = f"proc{id(target)}_{funcdef.function}"

                args = []
                for arg in funcdef.arguments:
                    args.append(f"scVariable {arg.name}")

                flag_code = f"static void SC_FASTCALL {funcname}(scSprite *sprite, {', '.join(args)}) {{\n"
                for stmt in inner_code:
                    flag_code += f"    {stmt}"
                flag_code += "\n}"

                code += flag_code

    code += "\n\n"

    info(f"Parsing entry scripts")
    scripts = []
    for i, target in enumerate(targets):
        for script in target.scripts:
            if script.opcode == "event_whenflagclicked":
                ast = generate_ast(script.next)

                inner_code = []
                for node in ast:
                    inner_code.append(generate_from_node(node, target))

                funcname = f"target{id(target)}_flag_clicked{id(script)}"
                scripts.append(f"{funcname}(&project.targets[{i}]);\n")

                flag_code = f"static void SC_FASTCALL {funcname}(scSprite *sprite) {{\n"
                for stmt in inner_code:
                    flag_code += f"    {stmt}"
                flag_code += "\n}"

                code += flag_code

    targets_code = ""

    for i, target in enumerate(targets):
        costumes_code = ""
        for j, costume in enumerate(target.costumes):
            costumes_code += f"targets[{i}].costumes[{j}] = scCostume_load(engine->renderer, \"project_data/{costume.file}\");"

        targets_code += f"""
    targets[{i}] = (scSprite){{
        .is_stage={int(target.is_stage)},
        .x={target.x},
        .y={target.y},
        .angle={target.direction},
        .visible={int(target.visible)},
        .draggable={int(target.draggable)},
        .current_costume = 0
    }};
    targets[{i}].max_costumes = {len(target.costumes)};
    {costumes_code}
"""

    code += f"""\n\n
int main(int argc, char **argv) {{
    project = scProject_default;
    project.metadata.scratch_ver = \"{project.scratch_ver}\";
    project.metadata.vm_ver = \"{project.vm_ver}\";
    project.metadata.user_agent = \"{project.user_agent}\";
    engine = scEngine_new(project);

    // Initialize global variables
    {stage_vars_code}

    project.targets_size = {len(targets)};
    scSprite targets[{len(targets)}];
    project.targets = targets;

    {targets_code}

    engine->is_running = true;
    while (engine->is_running) {{
        scEngine_tick(engine);

        scEngine_clear(engine);

        // Run scripts
        {"".join(scripts)}

        scEngine_render(engine, &project);

        scEngine_flush(engine);
    }}

    scEngine_free(engine);
    
    return EXIT_SUCCESS;
}}
"""

    return code