"""

    This file is a part of the Scratch to C
    project and distributed under the MIT license.

    Copyright Â© Kadir Aksoy
    https://github.com/kadir014/scratch2c

"""

from datetime import datetime

from .common import Project, Target
from .syntaxtree import *
from .terminal import info
#from .visualize import plot_ast


def is_number(value: str) -> bool:
    try:
        float(value)
        return True
    
    except ValueError:
        return False


FILE_DOC = \
f"""
/*

  This file was generated by the Scratch2C transpiler.

  +----------------------------------------+
  | Please do not manually edit this file  |
  | as it was generated automatically!     |
  +----------------------------------------+

  Scratch2C Project
  Github: https://github.com/kadir014/scratch2c

  Generated on: {datetime.now().strftime("%d/%m/%Y at %H:%M:%S")}

  For support or issues, please use the issue tracker:
    https://github.com/kadir014/scratch2c/issues
  
*/
""".strip()


VAR_TABLE = {}


def generate_from_node(node: Node, target: Target) -> str:
    if isinstance(node, Literal):
        if node.type == LiteralType.NUMBER:
            return f"SC_VARIABLE_REAL({node.value})"
        
        else:
            return f"SC_VARIABLE_STRING(\"{node.value}\")"
        
    elif isinstance(node, Variable):
        return VAR_TABLE[node.id]

    elif isinstance(node, Assignment):
        return f"scVariable_assign(&{VAR_TABLE[node.variable.id]}, {generate_from_node(node.expression, target)});\n"
    
    elif isinstance(node, MotionTurn):
        return f"sprite->angle {('-', '+')[node.cw]}= ({generate_from_node(node.angle, target)}).value_real;\n"
    
    elif isinstance(node, MotionMove):
        return f"scSprite_move(sprite, ({generate_from_node(node.steps, target)}).value_real);"
    
    elif isinstance(node, Repeat):
        inner_code = []
        for inner_node in node.body:
            inner_code.append(generate_from_node(inner_node, target))

        code = f"SC_REPEAT((sc_uint64)({generate_from_node(node.times, target)}.value_real)) {{\n"
        for stmt in inner_code:
            code += f"    {stmt}"
        code += "\n}"

        return code
    
    elif isinstance(node, RepeatUntil):
        inner_code = []
        for inner_node in node.body:
            inner_code.append(generate_from_node(inner_node, target))

        code = f"while (!({generate_from_node(node.condition, target)}.value_real)) {{\n"
        for stmt in inner_code:
            code += f"    {stmt}"
        code += "\n}"

        return code
    
    elif isinstance(node, If):
        inner_code = []
        for inner_node in node.body:
            inner_code.append(generate_from_node(inner_node, target))

        code = f"if ({generate_from_node(node.condition, target)}.value_real) {{\n"
        for stmt in inner_code:
            code += f"    {stmt}"
        code += "\n}"

        return code
    
    elif isinstance(node, IfElse):
        inner_code_if = []
        for inner_node in node.body_if:
            inner_code_if.append(generate_from_node(inner_node, target))

        inner_code_else = []
        for inner_node in node.body_else:
            inner_code_else.append(generate_from_node(inner_node, target))

        code = f"if ({generate_from_node(node.condition, target)}.value_real) {{\n"
        for stmt in inner_code_if:
            code += f"    {stmt}"
        code += "\n} else {"
        for stmt in inner_code_else:
            code += f"    {stmt}"
        code += "\n}"

        return code
    
    elif isinstance(node, Stop):
        if node.option == StopOption.THIS_SCRIPT:
            return f"return;\n"

    elif isinstance(node, BinOp):
        left = generate_from_node(node.left, target)
        right = generate_from_node(node.right, target)

        return f"sc_op_{node.type.name.lower()}({left}, {right})"

    elif isinstance(node, UnaryOp):
        right = generate_from_node(node.right, target)

        return f"sc_op_{node.type.name.lower()}({right})"
    
    elif isinstance(node, FunctionCall):
        args = []
        for arg in node.arguments:
            args.append(generate_from_node(arg, target))

        func = f"proc{id(target)}_{node.function}"

        if len(args) > 0:
            return f"{func}(sprite, {', '.join(args)});\n"
        else:
            return f"{func}(sprite);\n"
    
    elif isinstance(node, FunctionArgument):
        return f"{node.name}"
    
    elif isinstance(node, ListAction):
        if node.type == ListActionType.CLEAR:
            return f"scArray_clear({VAR_TABLE[node.list.id]}, NULL);\n"
        
        elif node.type == ListActionType.LENGTH:
            return f"SC_VARIABLE_REAL((sc_real){VAR_TABLE[node.list.id]}->size)"
        
        elif node.type == ListActionType.SHOW:
            return f"\n"
        
        elif node.type == ListActionType.HIDE:
            return f"\n"
        
        elif node.type == ListActionType.ADD:
            return f"scArray_add({VAR_TABLE[node.list.id]}, &{generate_from_node(node.param1, target)});\n"
        
        elif node.type == ListActionType.REMOVE:
            return f"scArray_remove({VAR_TABLE[node.list.id]}, (size_t)({generate_from_node(node.param1, target)}.value_real)-1);\n"
    
        elif node.type == ListActionType.ITEM:
            return f"(*(scVariable *)({VAR_TABLE[node.list.id]}->data[(size_t)({generate_from_node(node.param1, target)}.value_real)-1]))"
        
        elif node.type == ListActionType.ITEM_NO:
            # TODO
            return f""
        
        elif node.type == ListActionType.CONTAINS:
            # TODO
            return f""
        
        elif node.type == ListActionType.INSERT:
            # TODO
            return f""
        
        elif node.type == ListActionType.REPLACE:
            return f"*(scVariable *){VAR_TABLE[node.list.id]}->data[(size_t)({generate_from_node(node.param1, target)}.value_real)-1] = {generate_from_node(node.param2, target)};\n"

    elif isinstance(node, SensingReporter):
        if node.type == SensingReporterType.DAYSSINCE2000:
            return f"SC_VARIABLE_REAL(sc_days_since_2000())"

def generate_code(project: Project) -> str:
    targets = project.targets

    code = ""

    code += FILE_DOC
    
    code += """
    
#include "scratch/scratch.h"


/* Global project configuration */

scProject project;
scEngine *engine;


/* Global (stage) variables & lists */

"""

    stage = [t for t in targets if t.is_stage][0]

    vars_init = ""

    for var in stage.variables:
        VAR_TABLE[var.id] = f"g_{var.name}"

        code += f"scVariable g_{var.name};\n"
        vars_init += f"    g_{var.name}.type = scVariableType_REAL;\n"
        vars_init += f"    g_{var.name}.value_real = {var.value};\n"

    for lst in stage.lists:
        VAR_TABLE[var.id] = f"g_{lst.name}"

        code += f"scArray *g_{lst.name};\n"
        vars_init += f"    g_{lst.name} = scArray_new();\n"

        for val in lst.data:
            if is_number(val): vars_init += f"    scArray_add(g_{lst.name}, &SC_VARIABLE_REAL({val}));\n"
            else: vars_init +=  f"    scArray_add(g_{lst.name}, &SC_VARIABLE_STRING(\"{val}\"));\n"

    code += "\n/* Sprite variables & lists */\n\n"

    for target in targets:
        for var in target.variables:
            var_id = f"sprite{id(target)}_{var.name}"
            VAR_TABLE[var.id] = var_id

            code += f"scVariable {var_id};\n"
            vars_init += f"    {var_id}.type = scVariableType_REAL;\n"
            vars_init += f"    {var_id}.value_real = {var.value};\n"

        for lst in target.lists:
            lst_id = f"sprite{id(target)}_{lst.name}"
            VAR_TABLE[lst.id] = lst_id

            code += f"scArray *{lst_id};\n"
            vars_init += f"    {lst_id} = scArray_new();\n"

            for val in lst.data:
                if is_number(val): vars_init += f"    scArray_add({lst_id}, &SC_VARIABLE_REAL({val}));\n"
                else: vars_init +=  f"    scArray_add({lst_id}, &SC_VARIABLE_STRING(\"{val}\"));\n"

    code += "\n\n"

    info(f"Parsing procedure definitions")
    for i, target in enumerate(targets):
        for script in target.procedures:
            if script.opcode == "procedures_definition":
                funcdef = generate_ast_procdef(script)

                inner_code = []
                for node in funcdef.body:
                    inner_code.append(generate_from_node(node, target))

                funcname = f"proc{id(target)}_{funcdef.function}"

                args = []
                for arg in funcdef.arguments:
                    args.append(f"scVariable {arg.name}")

                if len(args) > 0:
                    flag_code = f"static void SC_FASTCALL {funcname}(scSprite *sprite, {', '.join(args)}) {{\n"
                else:
                    flag_code = f"static void SC_FASTCALL {funcname}(scSprite *sprite) {{\n"

                for stmt in inner_code:
                    flag_code += f"    {stmt}"
                flag_code += "\n}"

                code += flag_code

    code += "\n\n"

    info(f"Parsing entry scripts")
    scripts = []
    for i, target in enumerate(targets):
        for script in target.scripts:
            if script.opcode == "event_whenflagclicked":
                ast = generate_ast(script.next)

                inner_code = []
                for node in ast:
                    inner_code.append(generate_from_node(node, target))

                funcname = f"target{id(target)}_flag_clicked{id(script)}"
                scripts.append(f"{funcname}(&project.targets[{i}]);\n")

                flag_code = f"static void SC_FASTCALL {funcname}(scSprite *sprite) {{\n"
                for stmt in inner_code:
                    flag_code += f"    {stmt}"
                flag_code += "\n}"

                code += flag_code

    targets_code = ""

    for i, target in enumerate(targets):
        costumes_code = ""
        for j, costume in enumerate(target.costumes):
            costumes_code += f"targets[{i}].costumes[{j}] = scCostume_load(\"project_data/{costume.file}\");"

        targets_code += f"""
    targets[{i}] = (scSprite){{
        .is_stage={int(target.is_stage)},
        .x={target.x},
        .y={target.y},
        .angle={target.direction},
        .visible={int(target.visible)},
        .draggable={int(target.draggable)},
        .current_costume = 0
    }};
    targets[{i}].max_costumes = {len(target.costumes)};
    {costumes_code}
"""

    code += f"""\n\n
int main(int argc, char **argv) {{
    project = scProject_default;
    project.metadata.scratch_ver = \"{project.scratch_ver}\";
    project.metadata.vm_ver = \"{project.vm_ver}\";
    project.metadata.user_agent = \"{project.user_agent}\";
    engine = scEngine_new(project);

    // Initialize variables & lists
{vars_init}

    project.targets_size = {len(targets)};
    scSprite targets[{len(targets)}];
    project.targets = targets;

    {targets_code}

    engine->is_running = true;
    while (engine->is_running) {{
        scEngine_tick(engine);

        scEngine_clear(engine);

        // Run scripts
        {"".join(scripts)}

        scEngine_render(engine, &project);

        scEngine_flush(engine);
    }}

    scEngine_free(engine);
    
    return EXIT_SUCCESS;
}}
"""

    return code